SHELL = /bin/bash

MAKEFLAGS += --no-print-directory

# Project
NAME := $(file < NAME)
VERSION ?= $(file < VERSION)
GOPATH := $(shell go env GOPATH)
GOOS ?= $(shell go env GOOS)
GOARCH ?= $(shell go env GOARCH)
HASCMD := $(shell test -d cmd && echo "true")

ISRELEASED := $(shell git show-ref v$$(cat VERSION) 2>&1 > /dev/null && echo "true")

# Protobuf
PROTO := $(shell bash -c 'find pb* -type f -name \*.proto')
PROTOGO := $(patsubst %.proto,%.pb.go, $(PROTO))

# Utilities
# Default environment variables.
# Any variables already set will override the values in this file(s).
DOTENV := godotenv -f $(HOME)/.env,.env

# Variables
ROOT = $(shell pwd)

# Go
GOMODOPTS = GO111MODULE=on
GOGETOPTS = GO111MODULE=off
GOFILES := $(shell find . -name .git -prune -o -name '*.go' 2> /dev/null)
GODIRS = $(shell find . -maxdepth 1 -mindepth 1 -type d | egrep 'cmd|internal|pkg|api')

#
# End user targets
#

### HELP

.PHONY: help
help: ## Print Help
	@maker --menu=Makefile

### DEVELOPMENT

.PHONY: _build
_build: protobuf interfaces ## Build binary
	@test -d .cache || go fmt ./...
ifeq ($(HASCMD),true)
	@CGO_ENABLED=0 GOOS=linux GOARCH=amd64 $(MAKE) dist/$(NAME)_linux_amd64/$(NAME)server
	@$(MAKE) $(NAME)server
	@$(MAKE) $(NAME)client
endif

.PHONY: protobuf
protobuf: $(PROTOGO) ## Build protobuf
	@find pb* -maxdepth 0 -mindepth 0 -type d | xargs -L1 -I{} go get ./{}/...


.PHONY: _install
_install: $(GOPATH)/bin/$(NAME)server ## Install to $(GOPATH)/bin

.PHONY: clean
clean: ## Reset project to original state
	rm -rf .cache $(NAME)server $(NAME)client dist reports tmp vendor

.PHONY: test
test: ## Test
	$(MAKE) test_setup
	$(MAKE) goversion
	$(MAKE) lint
	@echo FEATURE FLAGS ENABLED
	FF_ENABLED=true $(MAKE) _test_fflags
	@echo FEATURE FLAGS DISABLED
	FF_ENABLED=false $(MAKE) _test_std
	@# Combined the return codes of all the tests
	@echo "Exit codes, unit tests: $$(cat reports/exitcode-unit.txt), golangci-lint: $$(cat reports/exitcode-golangci-lint.txt), golint: $$(cat reports/exitcode-golint.txt)"
	@exit $$(( $$(cat reports/exitcode-unit.txt) + $$(cat reports/exitcode-golangci-lint.txt) + $$(cat reports/exitcode-golint.txt) ))

# Test without feature flags
.PHONY: _test_std
_test_std:
	$(MAKE) unit
	$(MAKE) cx
	$(MAKE) cc

# Test with feature flags
.PHONY: _test_fflags
_test_fflags:
	$(MAKE) unit

.PHONY: goversion
goversion:
	@go version | grep go1.16

.PHONY: _unit
_unit:
	### Unit Tests
	gotestsum --jsonfile reports/unit.json --junitfile reports/junit.xml -- -timeout 60s -covermode atomic -coverprofile=./reports/coverage.out -v ./...; echo $$? > reports/exitcode-unit.txt
	@go-test-report -t "$(NAME) unit tests" -o reports/html/unit.html < reports/unit.json > /dev/null

.PHONY: _cc
_cc:
	### Code Coverage
	@go-acc -o ./reports/coverage.out ./... > /dev/null
	@go tool cover -func=./reports/coverage.out | tee reports/coverage.txt
	@go tool cover -html=reports/coverage.out -o reports/html/coverage.html

.PHONY: _cx
_cx:
	### Cyclomatix Complexity Report
	@gocyclo -avg $(GODIRS) | grep -v _test.go | tee reports/cyclomaticcomplexity.txt
	@contents=$$(cat reports/cyclomaticcomplexity.txt); echo "<html><title>cyclomatic complexity</title><body><pre>$${contents}</pre></body><html>" > reports/html/cyclomaticcomplexity.html

.PHONY: _test_setup
_test_setup:
	@mkdir -p tmp
	@mkdir -p reports/html

.PHONY: _release
_release: ## Trigger a release by creating a tag and pushing to the upstream repository
	@echo "### Releasing v$(VERSION)"
	@$(MAKE) _isreleased 2> /dev/null
	git tag v$(VERSION)
	git push --tags

# To be run inside a github workflow
.PHONY: _release_github
_release_github:

.PHONY: lint
lint: internal/version.go
	golangci-lint run --enable=gocyclo; echo $$? > reports/exitcode-golangci-lint.txt
	golint -set_exit_status ./..; echo $$? > reports/exitcode-golint.txt

.PHONY: tag
tag:
	git fetch --tags
	git tag v$(VERSION)
	git push --tags

.PHONY: deps
deps: go.mod ## Install build dependencies
	$(GOMODOPTS) go mod tidy
	$(GOMODOPTS) go mod download

.PHONY: depsdev
depsdev: ## Install development dependencies
ifeq ($(USEGITLAB),true)
	@mkdir -p $(ROOT)/.cache/{go,gomod}
endif
	cat .installs.txt | egrep -v '^#' | xargs -t -n1 go install

.PHONY: report
report: ## Open reports generated by "make test" in a browser
	@$(MAKE) $(REPORTS)

### Docker

.PHONY: _docker
_docker: ## Build docker image
	@($(MAKE) _build 2>&1) > /dev/null
	docker build -q -t $(NAME):$(VERSION) .

.PHONY: _run
_run: _docker ## Start docker container
	(docker stop $(NAME) 2>&1) > /dev/null || true
	docker run -d --rm -p 9090:9090 --init --name $(NAME) $(NAME):$(VERSION)

.PHONY: _stop
_stop: ## Stop docker container
	docker stop $(NAME)

.PHONY: _shell
_shell: ## Get a docker shell
	docker exec -it $(NAME) /bin/bash -l

.PHONY: _publish
_publish: _docker ## run docker push
	docker tag $(NAME):$(VERSION) $(DOCKER_URL)/$(NAME):$(VERSION)
	docker push $(DOCKER_URL)/$(NAME):$(VERSION)
	docker rmi $(DOCKER_URL)/$(NAME):$(VERSION)

### VERSION INCREMENT

.PHONY: bumpmajor
bumpmajor: ## Increment VERSION file ${major}.0.0 - major bump
	git fetch --tags
	versionbump --checktags major VERSION

.PHONY: bumpminor
bumpminor: ## Increment VERSION file 0.${minor}.0 - minor bump
	git fetch --tags
	versionbump --checktags minor VERSION

.PHONY: bumppatch
bumppatch: ## Increment VERSION file 0.0.${patch} - patch bump
	git fetch --tags
	versionbump --checktags patch VERSION

.PHONY: getversion
getversion:
	VERSION=$(VERSION) bash -c 'echo $$VERSION'

#
# Helper targets
#
# Open html reports
REPORTS = reports/html/unit.html reports/html/coverage.html reports/html/cyclomaticcomplexity.html
.PHONY: $(REPORTS)
$(REPORTS):
ifeq ($(GOOS),darwin)
	@test -f $@ && open $@
else ifeq ($(GOOS),linux)
	@test -f $@ && xdg-open $@
endif

# Check versionbump
.PHONY: _isreleased
_isreleased:
ifeq ($(ISRELEASED),true)
	@echo "Version $(VERSION) has been released."
	@echo "Please bump with 'make bump(minor|patch|major)' depending on breaking changes."
	@exit 1
endif

#
# File targets
#
$(GOPATH)/bin/$(NAME)server: $(NAME)server
	install -m 755 $(NAME)server $(GOPATH)/bin/$(NAME)server

$(NAME)server: dist/$(NAME)_$(GOOS)_$(GOARCH)/$(NAME)server
	install -m 755 $< $@

$(NAME)client: $(GOFILES)
	go build -o $@ ./cmd/$(NAME)client

dist/$(NAME)_$(GOOS)_$(GOARCH)/$(NAME)server dist/$(NAME)_$(GOOS)_$(GOARCH)/$(NAME)server.exe: $(GOFILES) internal/version.go
	@mkdir -p $$(dirname $@)
	go build -o $@ ./cmd/$(NAME)server

internal/version.go: internal/version.go.in VERSION
	@VERSION=$(VERSION) $(DOTENV) envsubst < $< > $@

%.pb.go: %.proto
	protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative $<
 
#
# make wrapper - Execute any target target prefixed with a underscore.
# EG 'make vmcreate' will result in the execution of 'make _vmcreate' 
#
%:
	@maker $@
